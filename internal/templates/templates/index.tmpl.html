{{- /* Go Template */ -}}
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Time</title>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Oswald&display=swap"
            rel="stylesheet"
        />
        <link rel="icon" href="https://andrewlester.net/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <style>
            h1 {
                font-family: 'Oswald';
                text-transform: uppercase;
            }

            h1 a {
                color: black;
                transition: color 100ms ease;
            }

            h1 a:first-child:hover {
                color: rgb(171, 25, 25);
            }

            h1 a:nth-child(2):hover {
                color: rgb(21, 167, 21);
            }
        </style>
    </head>
    <body>
        <h1>
            <a href="/">time.</a
            ><a href="https://andrewlester.net">andrewlester.net</a>
        </h1>
        <p>
            According to this server, the date is
            <span id="time">synchronzing...</span>. Your device's time is
            <span id="offset">synchronizing...</span>
        </p>
        {{ if .Region }}
        <p>Server running in the {{.Region}} region</p>
        {{ end }}

        <script>
            const elems = {
                time: document.getElementById('time'),
                offset: document.getElementById('offset'),
            };

            async function synchronize() {
                const peers = [];
                for (let i = 0; i < 1; i++) {
                    peers.push(await syncRequest());
                    await sleep(250);
                }

                let minDelayPeer = peers[0];
                for (const peer of peers) {
                    if (peer.delay < minDelayPeer.delay) {
                        minDelayPeer = peer;
                    }
                }

                const { offset } = minDelayPeer;
                const offsetMessage = offset < 0 ? 'ahead' : 'behind';
                elems.offset.textContent = `${offsetMessage} by ${Math.abs(
                    offset
                ).toFixed(3)} seconds`;

                elems.time.textContent = new Date(
                    (Date.now() / 1e3 + offset) * 1e3
                ).toLocaleString('en', {
                    dateStyle: 'full',
                    timeStyle: 'full',
                });
            }

            async function syncRequest() {
                const synchronizeRes = await fetch('/sync', {
                    method: 'POST',
                    body: JSON.stringify({
                        Orig: getSystemTime().toString(),
                    }),
                    headers: { 'content-type': 'application/json' },
                }).then((res) => res.json());
                synchronizeRes.Dst = getSystemTime(true);
                synchronizeRes.Orig = BigInt(synchronizeRes.Orig);
                synchronizeRes.Recv = BigInt(synchronizeRes.Recv);
                synchronizeRes.Xmt = BigInt(synchronizeRes.Xmt);

                console.log(
                    synchronizeRes.Recv,
                    synchronizeRes.Orig,
                    synchronizeRes.Xmt,
                    synchronizeRes.Dst,
                    '****',
                    ntpTimestampToDouble(
                        synchronizeRes.Recv - synchronizeRes.Orig
                    ),
                    ntpTimestampToDouble(
                        synchronizeRes.Xmt - synchronizeRes.Dst
                    )
                );

                return {
                    offset:
                        (ntpTimestampToDouble(
                            synchronizeRes.Recv - synchronizeRes.Orig
                        ) +
                            ntpTimestampToDouble(
                                synchronizeRes.Xmt - synchronizeRes.Dst
                            )) /
                        2,
                    delay:
                        ntpTimestampToDouble(
                            synchronizeRes.Dst - synchronizeRes.Orig
                        ) -
                        ntpTimestampToDouble(
                            synchronizeRes.Xmt - synchronizeRes.Recv
                        ),
                };
            }

            const eraLength = 4_294_967_296n; // 2^32
            const unixEraOffset = 2_208_988_800; // 1970 - 1900 in seconds

            let start;
            function getSystemTime(addLast = false) {
                let now = Date.now();
                if (!addLast) {
                    start = performance.now();
                } else {
                    const diff = performance.now() - start;
                    now += diff;
                }
                const seconds = Math.trunc(now / 1e3);
                const micros = (now * 1e3) % 1e6;
                return (
                    BigInt(seconds + unixEraOffset) * eraLength +
                    (BigInt(micros) * eraLength) / BigInt(1e6)
                );
            }

            // We only know us from Date.now() + performance.now()
            const decimalFactor = Math.pow(10, 6);
            function ntpTimestampToDouble(ntpTimestamp) {
                return (
                    Number((ntpTimestamp * BigInt(decimalFactor)) / eraLength) /
                    decimalFactor
                );
            }

            function sleep(millis) {
                return new Promise((resolve) => setTimeout(resolve, millis));
            }

            synchronize();
        </script>
    </body>
</html>
